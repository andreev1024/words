{"version":3,"file":"index.js","mappings":"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","sources":["webpack://words/./src/storage.ts","webpack://words/./src/word.ts","webpack://words/./src/html.ts","webpack://words/./src/stat.ts","webpack://words/./src/EditWord.ts","webpack://words/./src/LearnWord.ts","webpack://words/./src/state.ts","webpack://words/./src/main.ts","webpack://words/./src/AddWords.ts"],"sourcesContent":["import { createWords, Word } from './word';\n\nexport function getAllWordsOrException(): Word[] {\n    const storedWords = getAllWords();\n    if (storedWords.length === 0) {\n        throw new Error('No stored words');\n    }\n\n    return storedWords;\n}\n\nfunction getAllWords(): Word[] {\n    const storedWords = localStorage.getItem('words');\n    if (storedWords === null) {\n        return [];\n    }\n\n    return JSON.parse(storedWords);\n}\n\nexport function hasWords(): boolean {\n    const storedWords = localStorage.getItem('words');\n    if (storedWords === null) {\n        return false;\n    }\n\n    return JSON.parse(storedWords).length > 0;\n}\n\n//todo replace array with Words collection\nexport function updateWords(words: Word[]) {\n    const newWords = JSON.stringify(createWords(words).unique().toArray());\n    localStorage.setItem('words', newWords);\n}\n\nexport function replaceWord(prevWordKey: string, newWord: Word): void {\n    const words: Word[] = [];\n    getAllWordsOrException().forEach((word: Word) => words.push(word.en === prevWordKey ? newWord : word));\n    updateWords(words);\n}\n\nexport function addWords(words: Word[]) {\n    updateWords(getAllWords().concat(words));\n}\n\nexport function getWord(key: string): Word {\n    return createWords(getAllWordsOrException()).get(key);\n}\n\nexport function resetWords(): void {\n    localStorage.removeItem('words');\n}\n","import { getAllWordsOrException } from './storage';\nimport { Stat } from './stat';\n\nconst cyrillicPattern = /^[\\u0400-\\u04FF]+$/;\n\nexport type Word = {\n  en: string;\n  ru: string;\n};\n\nexport const createWord = (en: string, ru: string): Word => ({\n  en: en,\n  ru: ru,\n});\n\ntype Words = {\n  items: Word[];\n  unique: () => Words;\n  toArray: () => Word[];\n  get: (key: string) => Word;\n  find: (key: string) => undefined | Word;\n};\n\nexport const createWords = (words: Word[]): Words => ({\n  items: words,\n  unique() {\n    const uniqueWords: Record<string, Word> = {};\n    this.items.forEach((word: Word) => {\n      uniqueWords[word.en] = word;\n    });\n    return createWords(Object.values(uniqueWords));\n  },\n  toArray() {\n    return this.items;\n  },\n  get(key: string): Word {\n    const value = this.find(key);\n    if (value) {\n      return value;\n    }\n\n    throw new Error('Word does not exist');\n  },\n  find(key: string): undefined | Word {\n    return this.items.find((word: Word) => word.en === key);\n  },\n});\n\nfunction unexpectedError(message: string): never {\n  //   alert(message);\n  throw new Error(message);\n}\n\nexport function parseNewWords(input: string): Word[] {\n  const result: Word[] = [];\n  if (input.trim() === '') {\n    return result;\n  }\n\n  const rows = input.split('\\n');\n  rows.forEach(function (rawRow) {\n    //todo смена языка должна быть один раз\n    const row = rawRow.trim();\n    if (row === '') {\n      return;\n    }\n    let lang: null | string = null;\n    let anotherLangCharIndex: null | number = null;\n    [...row].forEach(function (value, index) {\n      if (anotherLangCharIndex) {\n        return;\n      }\n      if (value === ' ') {\n        return;\n      }\n      const charLang = cyrillicPattern.test(value) ? 'ru' : 'en';\n\n      if (lang === null) {\n        lang = charLang;\n        return;\n      }\n\n      if (lang !== charLang) {\n        if (anotherLangCharIndex !== null) {\n          unexpectedError('Invalid input');\n        }\n        anotherLangCharIndex = index;\n        return;\n      }\n    });\n\n    if (typeof anotherLangCharIndex !== 'number') {\n      unexpectedError('Invalid input');\n    }\n\n    const wordA = row.substring(0, anotherLangCharIndex).trim();\n    const wordB = row.substring(anotherLangCharIndex).trim();\n\n    result.push(\n      createWord(\n        !cyrillicPattern.test(wordA[0]) ? wordA : wordB,\n        cyrillicPattern.test(wordA[0]) ? wordA : wordB\n      )\n    );\n  });\n\n  if (result.length === 0) {\n    unexpectedError('Invalid input');\n  }\n\n  return result;\n}\n\nexport function getNextWord(stat: Stat, prevWord?: string): Word {\n  let allWords = getAllWordsOrException();\n  let nextWord = allWords[0];\n  if (allWords.length === 1) {\n    return nextWord;\n  }\n\n  let prevWordIndex;\n  if (prevWord !== undefined) {\n    prevWordIndex = allWords.findIndex((word: any) => word.en === prevWord);\n    if (prevWordIndex === -1) {\n      throw new Error('previous word index undefined');\n    }\n  }\n\n  if (prevWordIndex !== undefined) {\n    allWords.splice(prevWordIndex, 1);\n    const minShows = Math.min(\n      ...allWords.map((word: Word) => stat.get(word.en)?.shows ?? 0)\n    );\n    const words: Word[] = [];\n    allWords.forEach((word: Word) => {\n      const shows = stat.get(word.en)?.shows ?? 0;\n      if (shows - minShows < 1) {\n        words.push(word);\n      }\n    });\n    allWords = words;\n  }\n\n  nextWord = allWords[Math.floor(Math.random() * allWords.length)];\n\n  return nextWord;\n}\n\nexport function wordsEqual(a: string, b: string): boolean {\n  return normalize(a) === normalize(b);\n}\n\nfunction normalize(word: string): string {\n  const toBeForms: [RegExp, string][] = [\n    [/['’`]m/gi, ' am'], // I am - I'm\n    [/['’`]s/gi, ' is'], // He is - he's\n    [/['’`]re/gi, ' are'], // You are - you're\n  ];\n  toBeForms.forEach(([pattern, replacement]) => {\n    word = word.replace(pattern, replacement);\n  });\n\n  const tensesForms: [RegExp, string][] = [\n    [/['’`]ll/gi, ' will'], // I will - I'll\n  ];\n  tensesForms.forEach(([pattern, replacement]) => {\n    word = word.replace(pattern, replacement);\n  });\n\n  const replaceMultipleSpaces = /\\s+/g;\n  word = word.replace(replaceMultipleSpaces, ' ');\n  word = word.trim().toLowerCase();\n\n  return word;\n}\n","export const isHidden = (element: HTMLElement): boolean => element.offsetParent === null;\n\nexport const getElement = (id: string): HTMLElement => {\n    const element = document.getElementById(id);\n    if (element === null) {\n        throw new Error();\n    }\n    return element;\n};\n\nexport const getInputElement = (id: string): HTMLInputElement =>\n    getElement(id) as HTMLInputElement;\n\nexport const hide = (elem: HTMLElement) => {\n    elem.classList.add('hidden');\n};\n\nexport const show = (elem: HTMLElement) => {\n    elem.classList.remove('hidden');\n};\n","type StatItem = {\n    shows: number;\n    inc(key: string): void;\n};\n\nconst createStatItem = (): StatItem => ({\n    shows: 0,\n    inc(): void {\n        this.shows++;\n    },\n});\n\nexport type Stat = {\n    items: Record<string, StatItem>;\n    add: (key: string) => void;\n    get: (key: string) => undefined | StatItem;\n    reset: () => void;\n    updateKey: (prevKey: string, newKey: string) => void;\n};\n\n// singletone\nexport const stat: Stat = {\n    items: {},\n    add(key: string): void {\n        if (this.items[key] === undefined) {\n            this.items[key] = createStatItem();\n        }\n        this.items[key].inc(key);\n    },\n    get(key: string): undefined | StatItem {\n        return this.items[key];\n    },\n    reset(): void {\n        this.items = {};\n    },\n    updateKey(prevKey: string, newKey: string): void {\n        if (prevKey === newKey) {\n            return;\n        }\n\n        const item = this.get(prevKey);\n        if (!item) {\n            return;\n        }\n\n        //todo предотвратить перезапись другого слова (такое слово уже может быть в наборе)\n        // if (this.get(newKey)) {\n        //     throw new Error('such key already exist');\n        // }\n\n        this.items[newKey] = item;\n        delete this.items[prevKey];\n    },\n};\n","import { stat } from './stat';\nimport { LearnWord } from './LearnWord';\nimport { getInputElement, getElement, show, hide } from './html';\nimport { replaceWord } from './storage';\nimport { createWord, Word } from './word';\n\nexport class EditWord {\n    #elem: HTMLElement;\n\n    constructor() {\n        this.#elem = getElement('edit-word-wrapper');\n        this.#elem.onclick = this.#onClick.bind(this);\n    }\n\n    static show(word: Word): void {\n        const translationElement = EditWord.#getTranslationElement();\n        translationElement.dataset.prev = word.ru;\n        translationElement.value = word.ru;\n\n        const titleElement = EditWord.#getTitleElement();\n        titleElement.dataset.prev = word.en;\n        titleElement.value = word.en;\n\n        show(getInputElement('edit-word-wrapper'));\n    }\n\n    #onClick(event: any) {\n        const action = event.target?.dataset?.action;\n        if (action === 'save') {\n            this.#save();\n        }\n    }\n\n    #save(): void {\n        const translation = EditWord.#getTranslationElement();\n        const title = EditWord.#getTitleElement();\n        const prevTitle = title.dataset.prev;\n        const prevTranslation = translation.dataset.prev;\n\n        const newWord = createWord(title.value, translation.value);\n\n        //todo assert\n        if (prevTitle === undefined || prevTranslation === undefined) {\n            throw new Error();\n        }\n\n        if (prevTitle !== title.value || prevTranslation !== translation.value) {\n            //todo предотвратить перезапись другого слова (такое слово уже может быть в наборе)\n            replaceWord(prevTitle, newWord);\n            stat.updateKey(prevTitle, title.value);\n        }\n\n        LearnWord.show(newWord);\n        EditWord.#hide();\n    }\n\n    static #hide(): void {\n        hide(getInputElement('edit-word-wrapper'));\n    }\n\n    static #getTranslationElement(): HTMLInputElement {\n        return getInputElement('edit-word-translation');\n    }\n\n    static #getTitleElement(): HTMLInputElement {\n        return getInputElement('edit-word-title');\n    }\n}\n","import { Word, getNextWord, wordsEqual } from './word';\nimport { currentWord } from './state';\nimport { getInputElement, hide, getElement, show, isHidden } from './html';\nimport { EditWord } from './EditWord';\nimport { getWord, getAllWordsOrException, updateWords, resetWords } from './storage';\nimport { stat } from './stat';\n\nexport class LearnWord {\n    #elem: HTMLElement;\n\n    constructor() {\n        this.#elem = getElement('learn-word-wrapper');\n        this.#elem.onclick = this.#onClick.bind(this);\n        this.#elem.onkeydown = this.#onKeyDown.bind(this);\n    }\n\n    static show(word: Word): void {\n        hide(getElement('new-words-wrapper'));\n\n        getInputElement('word').value = word.ru;\n        getInputElement('correct-answer').value = word.en;\n\n        const userAnswerInputElement = getInputElement('user-answer');\n        userAnswerInputElement.value = '';\n        show(getElement('learn-word-wrapper'));\n        userAnswerInputElement.focus();\n    }\n\n    static isActive(): boolean {\n        return !isHidden(getElement('learn-word-wrapper'));\n    }\n\n    static showAnswer(): void {\n        const currentWord = getWord(getInputElement('correct-answer').value);\n        const wordElement = getInputElement('word');\n        wordElement.value = wordElement.value === currentWord.ru ? currentWord.en : currentWord.ru;\n    }\n\n    static skipWord(): void {\n        const currentWord = getInputElement('correct-answer').value;\n        const nextWord = getNextWord(stat, currentWord);\n        const allWords = getAllWordsOrException();\n\n        const currentWordIndex = allWords.findIndex((word) => word.en === currentWord);\n        if (currentWordIndex === -1) {\n            throw new Error(\"word doesn't exist\");\n        }\n\n        allWords.splice(currentWordIndex, 1);\n        updateWords(allWords);\n\n        allWords.length === 0 ? LearnWord.#showNewWordsSection() : LearnWord.show(nextWord);\n    }\n\n    static #showNewWordsSection(): void {\n        getInputElement('new-words').value = '';\n        show(getElement('new-words-wrapper'));\n        hide(getElement('learn-word-wrapper'));\n    }\n\n    static #resetStorage(): void {\n        resetWords();\n        LearnWord.#showNewWordsSection();\n    }\n\n    static #edit(): void {\n        LearnWord.#hide();\n        EditWord.show(currentWord());\n    }\n\n    static #checkWord(): void {\n        const userAnswerElement = getInputElement('user-answer');\n        const userAnswer = userAnswerElement.value;\n        const correctAnswer = getInputElement('correct-answer').value;\n        if (!wordsEqual(userAnswer, correctAnswer)) {\n            userAnswerElement.classList.add('red');\n            setTimeout(() => getElement('user-answer').classList.remove('red'), 1000);\n            return;\n        }\n\n        stat.add(correctAnswer);\n\n        const nextWord = getNextWord(stat, correctAnswer);\n        LearnWord.show(nextWord);\n    }\n\n    #onClick(event: any) {\n        const handlers: { [key: string]: { (): void } } = {\n            edit: LearnWord.#edit,\n            'show-answer': LearnWord.showAnswer,\n            'add-new-words': LearnWord.#showNewWordsSection,\n            skip: LearnWord.skipWord,\n            'reset-storage': LearnWord.#resetStorage,\n            check: LearnWord.#checkWord,\n        };\n\n        let action;\n        for (const key in handlers) {\n            if (event.target.closest(`[data-action=\"${key}\"]`)) {\n                action = key;\n                break;\n            }\n        }\n\n        if (!action) {\n            return;\n        }\n\n        const fn = handlers[action];\n        if (fn) {\n            fn();\n        }\n    }\n\n    #onKeyDown(event: KeyboardEvent) {\n        if (\n            event.target instanceof HTMLInputElement &&\n            event.target.id === 'user-answer' &&\n            event.code === 'Enter'\n        ) {\n            LearnWord.#checkWord();\n        }\n    }\n\n    static #hide(): void {\n        hide(getInputElement('learn-word-wrapper'));\n    }\n}\n","import { getInputElement } from './html';\nimport { getWord } from './storage';\n\n//todo user real state, not html\nexport const currentWord = () => getWord(getInputElement('correct-answer').value);\n","import { AddWords } from './AddWords';\nimport { LearnWord } from './LearnWord';\nimport { hasWords } from './storage';\nimport { getNextWord } from './word';\nimport { stat } from './stat';\nimport { getInputElement } from './html';\nimport { EditWord } from './EditWord';\n\n// todo\n\n// improve parsing\n// sssss cccccc\n// уууууу uuuuu\n//ффф ааа - ошибка в консоли\n// дефисы, и др знаки\n\n// FEATURES\n\n// H - версионность для css файлов\n// H - webpack hot reload\n\n// если 5 раз подряд написал слово верно не использоваа подсказку - показываем уведомление Молодец\n// дашборд с прогрессом, очками, как в rs app\n\n// H - должен работать без интернета\n// H - должен работать на разных устройствах (мобила, десктоп) и хранить стейт\n// H - когда смотришь подсказуку бывает удобно видеть сразу и перевод\n// H - примеры, или изучение в контексте\n\n// H - транскрипция\n// H - пишем ответ -> edit -> save -> ответ сбрасывается\n// H - просмотр статистики (кол-во показов, ошибок). Полезно что бы понимать какие слова стоит взять в сл.сессию\n// статистика после каждого цикла ИЛИ для сессии ИЛИ все время\n//      слова, где допустил ошибки и какие\n//      общее кол-во пройденных слов и сколько сделал ошибок\n\n// M - изучение в контексте предложения\n// M - если пытаешся добавить новое слово, но не ввел ни одного, то будет ошибка и Пользователь застрянет на этом\n// M - выгрузить оставшиеся слова. Выучил половину набора. Потом хочу переключиться на новый набор. А позже обьединить и делать оба\n\n// L - когда при edit такое слово уже существует (было аа  и aaa в бд. Обновляю aa на aaa и получаю ошибку)(для этого надо вводить UUID)\n\n// ADVANCED FEATURES\n//запоминание слов - yandex translator API\n//верстка под разные утсройства\n\n// REFACTORING\n// replace many files with one (bundling)\n// use words collection instead Word[]\n// replace duplicates in html\n// use state, not html (data attributes, current word)\n// лучше перенести в куки, тогда можно переключаться между устройствами\n// write tests\n\nconsole.log('AAa');\n\nconst initMultilinePlaceholder = () => {\n  const textarea = getInputElement('new-words');\n  textarea.placeholder = textarea.placeholder.replace(/\\\\n/g, '\\n');\n};\n\ndocument.addEventListener('keydown', (event: KeyboardEvent) => {\n  if (event.ctrlKey) {\n    if (LearnWord.isActive()) {\n      if (event.code === 'KeyA') {\n        LearnWord.showAnswer();\n        event.preventDefault();\n        return;\n      }\n      if (event.code === 'KeyS') {\n        LearnWord.skipWord();\n        return;\n      }\n    }\n  }\n});\n\ninitMultilinePlaceholder();\n\nif (hasWords()) {\n  LearnWord.show(getNextWord(stat));\n}\n\nnew AddWords();\nnew LearnWord();\nnew EditWord();\n","import { LearnWord } from './LearnWord';\nimport { stat } from './stat';\nimport { getElement } from './html';\nimport { getNextWord, parseNewWords } from './word';\nimport { addWords } from './storage';\n\nexport class AddWords {\n  #elem: HTMLElement;\n\n  constructor() {\n    this.#elem = getElement('new-words-wrapper');\n    this.#elem.onclick = this.#onClick.bind(this);\n  }\n\n  #learn(): void {\n    const newWords = parseNewWords(\n      (getElement('new-words') as HTMLInputElement).value\n    );\n\n    if (newWords.length === 0) {\n      // alert('Invalid input');\n      return;\n    }\n\n    stat.reset();\n\n    addWords(newWords);\n    LearnWord.show(getNextWord(stat));\n  }\n\n  #onClick(event: any) {\n    const action = event.target?.dataset?.action;\n    if (action === 'learn') {\n      this.#learn();\n    }\n  }\n}\n"],"names":["getAllWordsOrException","storedWords","getAllWords","length","Error","localStorage","getItem","JSON","parse","updateWords","words","newWords","stringify","createWords","unique","toArray","setItem","getWord","key","get","cyrillicPattern","createWord","en","ru","items","uniqueWords","this","forEach","word","Object","values","value","find","unexpectedError","message","getNextWord","stat","prevWord","prevWordIndex","allWords","nextWord","undefined","findIndex","splice","minShows","Math","min","map","shows","push","floor","random","normalize","pattern","replacement","replace","trim","toLowerCase","getElement","id","element","document","getElementById","getInputElement","hide","elem","classList","add","show","remove","createStatItem","inc","reset","updateKey","prevKey","newKey","item","EditWord","constructor","onclick","bind","translationElement","dataset","prev","titleElement","event","action","target","translation","title","prevTitle","prevTranslation","newWord","prevWordKey","replaceWord","LearnWord","onkeydown","userAnswerInputElement","focus","isActive","offsetParent","showAnswer","currentWord","wordElement","skipWord","currentWordIndex","removeItem","userAnswerElement","userAnswer","correctAnswer","b","setTimeout","handlers","edit","skip","check","closest","fn","HTMLInputElement","code","console","log","addEventListener","ctrlKey","preventDefault","textarea","placeholder","initMultilinePlaceholder","hasWords","input","result","split","rawRow","row","lang","anotherLangCharIndex","index","charLang","test","wordA","substring","wordB","parseNewWords","concat"],"sourceRoot":""}