{"version":3,"file":"index.js","mappings":"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","sources":["webpack://words/./src/storage.ts","webpack://words/./src/word.ts","webpack://words/./src/html.ts","webpack://words/./src/stat.ts","webpack://words/./src/EditWord.ts","webpack://words/./src/LearnWord.ts","webpack://words/./src/state.ts","webpack://words/./src/main.ts","webpack://words/./src/AddWords.ts"],"sourcesContent":["import { createWords, Word } from './word';\n\nexport function getAllWordsOrException(): Word[] {\n    const storedWords = getAllWords();\n    if (storedWords.length === 0) {\n        throw new Error('No stored words');\n    }\n\n    return storedWords;\n}\n\nfunction getAllWords(): Word[] {\n    const storedWords = localStorage.getItem('words');\n    if (storedWords === null) {\n        return [];\n    }\n\n    return JSON.parse(storedWords);\n}\n\nexport function hasWords(): boolean {\n    const storedWords = localStorage.getItem('words');\n    if (storedWords === null) {\n        return false;\n    }\n\n    return JSON.parse(storedWords).length > 0;\n}\n\n//todo replace array with Words collection\nexport function updateWords(words: Word[]) {\n    const newWords = JSON.stringify(createWords(words).unique().toArray());\n    localStorage.setItem('words', newWords);\n}\n\nexport function replaceWord(prevWordKey: string, newWord: Word): void {\n    const words: Word[] = [];\n    getAllWordsOrException().forEach((word: Word) => words.push(word.en === prevWordKey ? newWord : word));\n    updateWords(words);\n}\n\nexport function addWords(words: Word[]) {\n    updateWords(getAllWords().concat(words));\n}\n\nexport function getWord(key: string): Word {\n    return createWords(getAllWordsOrException()).get(key);\n}\n\nexport function resetWords(): void {\n    localStorage.removeItem('words');\n}\n","import { getAllWordsOrException } from './storage';\nimport { Stat } from './stat';\n\nconst cyrillicPattern = /^[\\u0400-\\u04FF]+$/;\n\nexport type Word = {\n    en: string;\n    ru: string;\n};\n\nexport const createWord = (en: string, ru: string): Word => ({\n    en: en,\n    ru: ru,\n});\n\ntype Words = {\n    items: Word[];\n    unique: () => Words;\n    toArray: () => Word[];\n    get: (key: string) => Word;\n    find: (key: string) => undefined | Word;\n};\n\nexport const createWords = (words: Word[]): Words => ({\n    items: words,\n    unique() {\n        const uniqueWords: Record<string, Word> = {};\n        this.items.forEach((word: Word) => {\n            uniqueWords[word.en] = word;\n        });\n        return createWords(Object.values(uniqueWords));\n    },\n    toArray() {\n        return this.items;\n    },\n    get(key: string): Word {\n        const value = this.find(key);\n        if (value) {\n            return value;\n        }\n\n        throw new Error('Word does not exist');\n    },\n    find(key: string): undefined | Word {\n        return this.items.find((word: Word) => word.en === key);\n    },\n});\n\nfunction unexpectedError(message: string): never {\n    alert(message);\n    throw new Error(message);\n}\n\nexport function parseNewWords(input: string): Word[] {\n    const result: Word[] = [];\n    if (input.trim() === '') {\n        return result;\n    }\n\n    const rows = input.split('\\n');\n    rows.forEach(function (rawRow) {\n        //todo смена языка должна быть один раз\n        const row = rawRow.trim();\n        if (row === '') {\n            return;\n        }\n        let lang: null | string = null;\n        let anotherLangCharIndex: null | number = null;\n        [...row].forEach(function (value, index) {\n            if (anotherLangCharIndex) {\n                return;\n            }\n            if (value === ' ') {\n                return;\n            }\n            const charLang = cyrillicPattern.test(value) ? 'ru' : 'en';\n\n            if (lang === null) {\n                lang = charLang;\n                return;\n            }\n\n            if (lang !== charLang) {\n                if (anotherLangCharIndex !== null) {\n                    unexpectedError('Invalid input');\n                }\n                anotherLangCharIndex = index;\n                return;\n            }\n        });\n\n        if (typeof anotherLangCharIndex !== 'number') {\n            unexpectedError('Invalid input');\n        }\n\n        const wordA = row.substring(0, anotherLangCharIndex).trim();\n        const wordB = row.substring(anotherLangCharIndex).trim();\n\n        result.push(\n            createWord(\n                !cyrillicPattern.test(wordA[0]) ? wordA : wordB,\n                cyrillicPattern.test(wordA[0]) ? wordA : wordB\n            )\n        );\n    });\n\n    if (result.length === 0) {\n        unexpectedError('Invalid input');\n    }\n\n    return result;\n}\n\nexport function getNextWord(stat: Stat, prevWord?: string): Word {\n    let allWords = getAllWordsOrException();\n    let nextWord = allWords[0];\n    if (allWords.length === 1) {\n        return nextWord;\n    }\n\n    let prevWordIndex;\n    if (prevWord !== undefined) {\n        prevWordIndex = allWords.findIndex((word: any) => word.en === prevWord);\n        if (prevWordIndex === -1) {\n            throw new Error('previous word index undefined');\n        }\n    }\n\n    if (prevWordIndex !== undefined) {\n        allWords.splice(prevWordIndex, 1);\n        const minShows = Math.min(...allWords.map((word: Word) => stat.get(word.en)?.shows ?? 0));\n        const words: Word[] = [];\n        allWords.forEach((word: Word) => {\n            const shows = stat.get(word.en)?.shows ?? 0;\n            if (shows - minShows < 1) {\n                words.push(word);\n            }\n        });\n        allWords = words;\n    }\n\n    nextWord = allWords[Math.floor(Math.random() * allWords.length)];\n\n    return nextWord;\n}\n\nexport function wordsEqual(a: string, b: string): boolean {\n    return normalize(a) === normalize(b);\n}\n\nfunction normalize(word: string): string {\n    const toBeForms: [RegExp, string][] = [\n        [/['’`]m/gi, ' am'], // I am - I'm\n        [/['’`]s/gi, ' is'], // He is - he's\n        [/['’`]re/gi, ' are'], // You are - you're\n    ];\n    toBeForms.forEach(([pattern, replacement]) => {\n        word = word.replace(pattern, replacement);\n    });\n\n    const tensesForms: [RegExp, string][] = [\n        [/['’`]ll/gi, ' will'], // I will - I'll\n    ];\n    tensesForms.forEach(([pattern, replacement]) => {\n        word = word.replace(pattern, replacement);\n    });\n\n    const replaceMultipleSpaces = /\\s+/g;\n    word = word.replace(replaceMultipleSpaces, ' ');\n    word = word.trim().toLowerCase();\n\n    return word;\n}\n","export const isHidden = (element: HTMLElement): boolean => element.offsetParent === null;\n\nexport const getElement = (id: string): HTMLElement => {\n    const element = document.getElementById(id);\n    if (element === null) {\n        throw new Error();\n    }\n    return element;\n};\n\nexport const getInputElement = (id: string): HTMLInputElement =>\n    getElement(id) as HTMLInputElement;\n\nexport const hide = (elem: HTMLElement) => {\n    elem.classList.add('hidden');\n};\n\nexport const show = (elem: HTMLElement) => {\n    elem.classList.remove('hidden');\n};\n","type StatItem = {\n    shows: number;\n    inc(key: string): void;\n};\n\nconst createStatItem = (): StatItem => ({\n    shows: 0,\n    inc(): void {\n        this.shows++;\n    },\n});\n\nexport type Stat = {\n    items: Record<string, StatItem>;\n    add: (key: string) => void;\n    get: (key: string) => undefined | StatItem;\n    reset: () => void;\n    updateKey: (prevKey: string, newKey: string) => void;\n};\n\n// singletone\nexport const stat: Stat = {\n    items: {},\n    add(key: string): void {\n        if (this.items[key] === undefined) {\n            this.items[key] = createStatItem();\n        }\n        this.items[key].inc(key);\n    },\n    get(key: string): undefined | StatItem {\n        return this.items[key];\n    },\n    reset(): void {\n        this.items = {};\n    },\n    updateKey(prevKey: string, newKey: string): void {\n        if (prevKey === newKey) {\n            return;\n        }\n\n        const item = this.get(prevKey);\n        if (!item) {\n            return;\n        }\n\n        //todo предотвратить перезапись другого слова (такое слово уже может быть в наборе)\n        // if (this.get(newKey)) {\n        //     throw new Error('such key already exist');\n        // }\n\n        this.items[newKey] = item;\n        delete this.items[prevKey];\n    },\n};\n","import { stat } from './stat';\nimport { LearnWord } from './LearnWord';\nimport { getInputElement, getElement, show, hide } from './html';\nimport { replaceWord } from './storage';\nimport { createWord, Word } from './word';\n\nexport class EditWord {\n    #elem: HTMLElement;\n\n    constructor() {\n        this.#elem = getElement('edit-word-wrapper');\n        this.#elem.onclick = this.#onClick.bind(this);\n    }\n\n    static show(word: Word): void {\n        const translationElement = EditWord.#getTranslationElement();\n        translationElement.dataset.prev = word.ru;\n        translationElement.value = word.ru;\n\n        const titleElement = EditWord.#getTitleElement();\n        titleElement.dataset.prev = word.en;\n        titleElement.value = word.en;\n\n        show(getInputElement('edit-word-wrapper'));\n    }\n\n    #onClick(event: any) {\n        const action = event.target?.dataset?.action;\n        if (action === 'save') {\n            this.#save();\n        }\n    }\n\n    #save(): void {\n        const translation = EditWord.#getTranslationElement();\n        const title = EditWord.#getTitleElement();\n        const prevTitle = title.dataset.prev;\n        const prevTranslation = translation.dataset.prev;\n\n        const newWord = createWord(title.value, translation.value);\n\n        //todo assert\n        if (prevTitle === undefined || prevTranslation === undefined) {\n            throw new Error();\n        }\n\n        if (prevTitle !== title.value || prevTranslation !== translation.value) {\n            //todo предотвратить перезапись другого слова (такое слово уже может быть в наборе)\n            replaceWord(prevTitle, newWord);\n            stat.updateKey(prevTitle, title.value);\n        }\n\n        LearnWord.show(newWord);\n        EditWord.#hide();\n    }\n\n    static #hide(): void {\n        hide(getInputElement('edit-word-wrapper'));\n    }\n\n    static #getTranslationElement(): HTMLInputElement {\n        return getInputElement('edit-word-translation');\n    }\n\n    static #getTitleElement(): HTMLInputElement {\n        return getInputElement('edit-word-title');\n    }\n}\n","import { Word, getNextWord, wordsEqual } from './word';\nimport { currentWord } from './state';\nimport { getInputElement, hide, getElement, show, isHidden } from './html';\nimport { EditWord } from './EditWord';\nimport { getWord, getAllWordsOrException, updateWords, resetWords } from './storage';\nimport { stat } from './stat';\n\nexport class LearnWord {\n    #elem: HTMLElement;\n\n    constructor() {\n        this.#elem = getElement('learn-word-wrapper');\n        this.#elem.onclick = this.#onClick.bind(this);\n        this.#elem.onkeydown = this.#onKeyDown.bind(this);\n    }\n\n    static show(word: Word): void {\n        hide(getElement('new-words-wrapper'));\n\n        getInputElement('word').value = word.ru;\n        getInputElement('correct-answer').value = word.en;\n\n        const userAnswerInputElement = getInputElement('user-answer');\n        userAnswerInputElement.value = '';\n        show(getElement('learn-word-wrapper'));\n        userAnswerInputElement.focus();\n    }\n\n    static isActive(): boolean {\n        return !isHidden(getElement('learn-word-wrapper'));\n    }\n\n    static showAnswer(): void {\n        const currentWord = getWord(getInputElement('correct-answer').value);\n        const wordElement = getInputElement('word');\n        wordElement.value = wordElement.value === currentWord.ru ? currentWord.en : currentWord.ru;\n    }\n\n    static skipWord(): void {\n        const currentWord = getInputElement('correct-answer').value;\n        const nextWord = getNextWord(stat, currentWord);\n        const allWords = getAllWordsOrException();\n\n        const currentWordIndex = allWords.findIndex((word) => word.en === currentWord);\n        if (currentWordIndex === -1) {\n            throw new Error(\"word doesn't exist\");\n        }\n\n        allWords.splice(currentWordIndex, 1);\n        updateWords(allWords);\n\n        allWords.length === 0 ? LearnWord.#showNewWordsSection() : LearnWord.show(nextWord);\n    }\n\n    static #showNewWordsSection(): void {\n        getInputElement('new-words').value = '';\n        show(getElement('new-words-wrapper'));\n        hide(getElement('learn-word-wrapper'));\n    }\n\n    static #resetStorage(): void {\n        resetWords();\n        LearnWord.#showNewWordsSection();\n    }\n\n    static #edit(): void {\n        LearnWord.#hide();\n        EditWord.show(currentWord());\n    }\n\n    static #checkWord(): void {\n        const userAnswerElement = getInputElement('user-answer');\n        const userAnswer = userAnswerElement.value;\n        const correctAnswer = getInputElement('correct-answer').value;\n        if (!wordsEqual(userAnswer, correctAnswer)) {\n            userAnswerElement.classList.add('red');\n            setTimeout(() => getElement('user-answer').classList.remove('red'), 1000);\n            return;\n        }\n\n        stat.add(correctAnswer);\n\n        const nextWord = getNextWord(stat, correctAnswer);\n        LearnWord.show(nextWord);\n    }\n\n    #onClick(event: any) {\n        const handlers: { [key: string]: { (): void } } = {\n            edit: LearnWord.#edit,\n            'show-answer': LearnWord.showAnswer,\n            'add-new-words': LearnWord.#showNewWordsSection,\n            skip: LearnWord.skipWord,\n            'reset-storage': LearnWord.#resetStorage,\n            check: LearnWord.#checkWord,\n        };\n\n        let action;\n        for (const key in handlers) {\n            if (event.target.closest(`[data-action=\"${key}\"]`)) {\n                action = key;\n                break;\n            }\n        }\n\n        if (!action) {\n            return;\n        }\n\n        const fn = handlers[action];\n        if (fn) {\n            fn();\n        }\n    }\n\n    #onKeyDown(event: KeyboardEvent) {\n        if (\n            event.target instanceof HTMLInputElement &&\n            event.target.id === 'user-answer' &&\n            event.code === 'Enter'\n        ) {\n            LearnWord.#checkWord();\n        }\n    }\n\n    static #hide(): void {\n        hide(getInputElement('learn-word-wrapper'));\n    }\n}\n","import { getInputElement } from './html';\nimport { getWord } from './storage';\n\n//todo user real state, not html\nexport const currentWord = () => getWord(getInputElement('correct-answer').value);\n","import { AddWords } from './AddWords';\nimport { LearnWord } from './LearnWord';\nimport { hasWords } from './storage';\nimport { getNextWord } from './word';\nimport { stat } from './stat';\nimport { getInputElement } from './html';\nimport { EditWord } from './EditWord';\n\n// todo\n\n// improve parsing\n// sssss cccccc\n// уууууу uuuuu\n//ффф ааа - ошибка в консоли\n// дефисы, и др знаки\n\n// FEATURES\n\n// H - версионность для css файлов\n// H - webpack hot reload\n\n// если 5 раз подряд написал слово верно не использоваа подсказку - показываем уведомление Молодец\n// дашборд с прогрессом, очками, как в rs app\n\n// H - должен работать без интернета\n// H - должен работать на разных устройствах (мобила, десктоп) и хранить стейт\n// H - когда смотришь подсказуку бывает удобно видеть сразу и перевод\n// H - примеры, или изучение в контексте\n\n// H - транскрипция\n// H - пишем ответ -> edit -> save -> ответ сбрасывается\n// H - просмотр статистики (кол-во показов, ошибок). Полезно что бы понимать какие слова стоит взять в сл.сессию\n// статистика после каждого цикла ИЛИ для сессии ИЛИ все время\n//      слова, где допустил ошибки и какие\n//      общее кол-во пройденных слов и сколько сделал ошибок\n\n// M - изучение в контексте предложения\n// M - если пытаешся добавить новое слово, но не ввел ни одного, то будет ошибка и Пользователь застрянет на этом\n// M - выгрузить оставшиеся слова. Выучил половину набора. Потом хочу переключиться на новый набор. А позже обьединить и делать оба\n\n// L - когда при edit такое слово уже существует (было аа  и aaa в бд. Обновляю aa на aaa и получаю ошибку)(для этого надо вводить UUID)\n\n// ADVANCED FEATURES\n//запоминание слов - yandex translator API\n//верстка под разные утсройства\n\n// REFACTORING\n// replace many files with one (bundling)\n// use words collection instead Word[]\n// replace duplicates in html\n// use state, not html (data attributes, current word)\n// лучше перенести в куки, тогда можно переключаться между устройствами\n// write tests\n\nconst initMultilinePlaceholder = () => {\n    const textarea = getInputElement('new-words');\n    textarea.placeholder = textarea.placeholder.replace(/\\\\n/g, '\\n');\n};\n\ndocument.addEventListener('keydown', (event: KeyboardEvent) => {\n    if (event.ctrlKey) {\n        if (LearnWord.isActive()) {\n            if (event.code === 'KeyA') {\n                LearnWord.showAnswer();\n                event.preventDefault();\n                return;\n            }\n            if (event.code === 'KeyS') {\n                LearnWord.skipWord();\n                return;\n            }\n        }\n    }\n});\n\ninitMultilinePlaceholder();\n\nif (hasWords()) {\n    LearnWord.show(getNextWord(stat));\n}\n\nnew AddWords();\nnew LearnWord();\nnew EditWord();\n","import { LearnWord } from './LearnWord';\nimport { stat } from './stat';\nimport { getElement } from './html';\nimport { getNextWord, parseNewWords } from './word';\nimport { addWords } from './storage';\n\nexport class AddWords {\n    #elem: HTMLElement;\n\n    constructor() {\n        this.#elem = getElement('new-words-wrapper');\n        this.#elem.onclick = this.#onClick.bind(this);\n    }\n\n    #learn(): void {\n        const newWords = parseNewWords(\n            (getElement('new-words') as HTMLInputElement).value\n        );\n\n        if (newWords.length === 0) {\n            alert('Invalid input');\n            return;\n        }\n\n        stat.reset();\n\n        addWords(newWords);\n        LearnWord.show(getNextWord(stat));\n    }\n\n    #onClick(event: any) {\n        const action = event.target?.dataset?.action;\n        if (action === 'learn') {\n            this.#learn();\n        }\n    }\n}\n"],"names":["getAllWordsOrException","storedWords","getAllWords","length","Error","localStorage","getItem","JSON","parse","updateWords","words","newWords","stringify","createWords","unique","toArray","setItem","getWord","key","get","cyrillicPattern","createWord","en","ru","items","uniqueWords","this","forEach","word","Object","values","value","find","unexpectedError","message","alert","getNextWord","stat","prevWord","prevWordIndex","allWords","nextWord","undefined","findIndex","splice","minShows","Math","min","map","shows","push","floor","random","normalize","pattern","replacement","replace","trim","toLowerCase","getElement","id","element","document","getElementById","getInputElement","hide","elem","classList","add","show","remove","createStatItem","inc","reset","updateKey","prevKey","newKey","item","EditWord","constructor","onclick","bind","translationElement","dataset","prev","titleElement","event","action","target","translation","title","prevTitle","prevTranslation","newWord","prevWordKey","replaceWord","LearnWord","onkeydown","userAnswerInputElement","focus","isActive","offsetParent","showAnswer","currentWord","wordElement","skipWord","currentWordIndex","removeItem","userAnswerElement","userAnswer","correctAnswer","b","setTimeout","handlers","edit","skip","check","closest","fn","HTMLInputElement","code","addEventListener","ctrlKey","preventDefault","textarea","placeholder","initMultilinePlaceholder","hasWords","input","result","split","rawRow","row","lang","anotherLangCharIndex","index","charLang","test","wordA","substring","wordB","parseNewWords","concat"],"sourceRoot":""}